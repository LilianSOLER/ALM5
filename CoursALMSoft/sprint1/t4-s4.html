<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html lang="en-US">  <head>    <meta http-equiv="content-type" content="text/html; charset=utf-8">    <title>Workshop: Programming Basics</title>    <meta name="CHANGEDBY" content="Pr. Olivier Gruber">    <link rel="stylesheet" href="../style.css" type="text/css">    <script src="../common.js"></script>    <script src="../quizz.js"></script>    <link rel="stylesheet" href="../highlight.js/styles/default.css">    <script src="../highlight.js/highlight.pack.js"></script>    <script>hljs.initHighlightingOnLoad();</script>  </head>  <body onload="shellOnLoad()">    <script>      function shellOnLoad() {        multiLang();        /*hljs.initHighlightingOnLoad(); */        _quizzes = new Array();        parseQuizzes();      }      </script>    <div id="outer-container">      <div id="header">        <div id="logo"> <img src="../logo_uga.png" alt="Université Grenoble-Alpes"            border="0"            height="100">          <img src="../logo_reseau_polytech.gif" alt="Polytech" border="0" height="80">        </div>        <div id="top-links"> <a href="../index.html">Home</a> </div>      </div>      <div id="inner-container">        <h1>Sprint: Assembly Programming Basics</h1>        <h2>Task4 -- Gestion de la pile</h2>        <h3>Step 4 -- La pile en C</h3>        <p> En C, la pile n'est pas visible directement par le programmeur. Il          est en revanche possible, lors du débug, d'observer son contenu,          d'analyser l'arbre d'appels de fonctions. C'est ce que nous allons          faire maintenant. </p>        <p> Avant de réaliser ces observations, il est nécessaire de comprendre          comment GCC utilise la pile. </p>        <ul>          <li> GCC utilise une pile <b><i>descendante</i></b>, de la même            manière que nous l'avons fait précédemment en ARM, le pointeur de            pile <b>SP évolue donc en étant décrémenté lors de l'empilement</b>.</li>        </ul>        <ul>          <li> Les registres étant composés de 32 bits, ils occupent 4 octets en            mémoire. Le pointeur de pile SP évolue donc de 4 en 4 car les            adresses mémoires pointent sur des octets individuels.</li>        </ul>        <p> Notez que vous pouvez représenter graphiquement la pile dans l'ordre          que vous désirez. Soit de bas en haut, les adresses les plus petites          en haut. Soit de haut en bas, les adresses les plus petites étant en          bas.</p>        <p> La deuxième solution est plus pratique, car vous n'aurez pas à          deviner de combien de place vous aurez besoin, avant de dessiner la          pile à partir du bas. Cependant GDB affichera la mémoire dans l'ordre          des adresses croissantes. A vous de choisir ce qui vous plait le          plus... </p>        <p><br>        </p>        Placez vous dans le répertoire task4s4C.<br>        Compilez le programme pingpong en utilisant la commande make pingpong.s        puis ouvrez les fichier pingpong.c et pingpong.s pour observer ce que        GCC a généré<b>.</b>        <p></p>        <p><b></b> <br>          <i> Le programme assembleur que nous allons étudier fait presque 100            lignes !<br>            N'ayez pas peur, nous allons le parcourir morceau par morceau. Ne            tentez pas de tout lire d'un coup et suivez le guide ! </i> </p>        <h3></h3>        <h4>Les addresses de retour et le Frame Pointer</h4>        <p> <b> </b>Dans la suite et jusqu'aux observation avec GDB, nous          considèrerons que la pile démarre à l'adresse <i>0xFF</i>. C'est à          dire qu'avant de démarrer l'exécution, <i>SP</i> est initialisé avec          la valeur <i>0xFF</i>. </p>        <br>        <b> Observez la fonction <i>main</i>. </b>        <p>La première instruction qu'elle exécute est un <i>push</i> dans la          pile.<br>          <i>stmfd sp!, {fp, lr}</i> (ou <i>push {fp, lr}</i>) empile <i>LR</i>          puis <i>FP</i> dans la pile à partir de <i>SP-4</i>, en allant dans          le sens des adresses décroissantes, puis fait pointer <i>SP</i> sur          l'endroit où a été stocké le dernier élement empilé, c'est à dire <i>FP</i>.        </p>        <p> Voici l'évolution de la pile avant et après cette instruction. </p>        <p> Avant</p>        <pre>             ------------SP = 0xFF -&gt; | XXXXXXXX |             ------------</pre>        <p> Après</p>        <pre>      ------------    |SP -&gt; | FP = 0   |    |      ------------    |  Adresses croissantes0xFF  | LR = 0   |    v      ------------</pre>        <p> Ici nous considérons que les premières valeurs de <i>FP</i> et <i>LR</i>          sont à 0 par défaut. </p>        <br>        <p> Ensuite, le registre <i>FP</i> est initialisé à <i>SP + 4</i>, ce          qui nous donne l'état ci-dessous juste avant l'appel à la fonction <i>ping</i>.        </p>        <pre>      ------------SP -&gt; | FP       |      ------------FP -&gt; | LR       |      ------------</pre>        <p> <i><b>FP</b></i> (pour Frame Pointer) correspond au registre <b><i>R11</i></b>.          Il est utilisé comme pointeur dans la pile, pour permettre d'accéder          aux différents éléments stockés dans la pile à partir de celui-ci.          Nous verrons comment juste après. </p>        <br>        <b> Observez l'appel de ping dans le <i>main</i>: </b><br>        <ul>          <li> Le premier paramètre est "passé" par le registre <i>r0</i>. Cela            fait partie de la "convention d'appel" choisie par GCC. </li>        </ul>        <ul>          <li> La valeur de retour est également passée par le registre <i>r0</i>,            écrasant la valeur du premier paramètre. Si cela est nécessaire, GCC            prendra bien sûr soin de le sauvegarder par ailleurs. </li>        </ul>        <p> Jusque-là, rien de nouveau. <b><br>          </b></p>        <br>        <b>Observez maintenant la fonction ping. <br>          Quelle est la première chose que fait la fonction ping ?</b> <br>        <br>        Dessinez le nouvel état de la pile juste après la première instruction        de la fonction ping (<i><b>stmfd</b></i>). <i><br>        </i><br>        <ul>          <li>Pour distinguer les différentes valeurs que prennent <i>SP</i>, <i>LR</i>            et <i>FP</i> dans la pile, calculez à la main les valeurs qu'ils            prennent au cours de l'exécution.</li>        </ul>        <ul>          <li><i> </i>Pour <i>SP</i> écrivez le simplement à gauche sous forme            de pointeur.</li>        </ul>        <ul>          <li> Pour <i>FP</i> écrivez le sous forme de pointeur également, ou            lorsqu'il est stocké dans la pile, écrivez l'adresse stockée            également.</li>        </ul>        <ul>          <li> Pour <i>LR</i>, vous pouvez écrire le numéro de ligne            correspondant dans le code assembleur.</li>        </ul>        <p> Par exemple : </p>        <pre>         ------------SP -&gt;    | FP = 0xFF|         ------------         | LR = 78  |         ------------         ------------         | FP = 0   |         ------------FP -&gt;    | LR = 0   |         ------------</pre> <br>        <p> On observe ensuite que FP est initialisé à <i>SP+4</i>. C'est la          raison pour laquelle il a été stocké dans la pile juste avant. Sa          valeur sera restaurée juste avant de terminer la fonction. </p>        <b> Mettez à jour FP sur l'état de la pile <br>        </b>        <p> Ensuite, le registre <i>SP</i> est décrémenté de 8, pour laisser de          la place pour la sauvegarde des registres et des variables locales. <i><br>          </i></p>        <b> Dessinez le nouvel état de la pile </b><br>        <p> Pour résumer, la première chose qui est faite dans une fonction est          de préparer son espace de pile :<br>        </p>        <ul>          <li> Sauvegarde de LR et FP dans la pile </li>          <li> Initialisation de FP </li>          <li> Décrémenter SP pour allouer de la place pour sauvegarder les            registres et les variables locales. </li>        </ul>        <p></p>        <p> Sautons maintenant à la fin de la fonction.</p>        <br>        <b> Observez les deux instructions précédent bx lr (lignes 32 et 33), à          la fin de la fonction ping.</b><br>        <p><br>          La fonction restaure les valeurs de SP, FP et LR tel quelles étaient          avant l'appel à ping.</p>        <br>        <b> Dessinez la pile juste avant l'exécution de l'instruction bx lr </b><br>        <h3></h3>        <h4>Les registres</h4>        <p> L'espace laissé en décrémentant <i>SP</i> de 8, au début de la          fonction, sert en partie à sauvegarder les registres.</p>        <br>        <b> Observez le code assembleur après l'instruction sub sp, sp, #8 et          dessinez la pile après la sauvegarde du ou des registres dans la pile</b><br>        <p><b></b> <br>          <i>Dans la pile, notez le registre et sa valeur, par exemple :</i> </p>        <pre>         ------------SP -&gt;    | R0 = 42  |         ------------         | FP = 0   |         ------------FP -&gt;    | LR = 0   |         ------------</pre>        <h3></h3>        <h4>Les variables locales</h4>        <p> Les variables locales sont également stockées dans la pile. Ceci          permet en particulier de pouvoir appeler récursivement une fonction,          en conservant l'état des variables locales de la fonction pour chaque          instance d'appel de celle-ci. </p>        <br>        <b> Observez la fonction pong. </b>        <p>Celle-ci utilise deux variables locales a et b.</p>        <b> </b><br>        <b> En observant la fonction pong, déterminez à quelle endroit dans la          pile sont stockées les variables a et b. </b><br>        <p>Pour vous aider, ces variables sont initialisées différemment. Par          exemple, pour trouver la variable a dans l'assembleur, cherchez à quel          endroit une addition avec 42 est faites, puis déterminez à quel          endroit dans la pile le résultat de cette addition est stocké.          Utilisez le même procédé pour trouver b. </p>        <br>        <b> Dessinez l'état de la pile au moment de l'instruction bl ping </b><br>        <p> <i> Question annexe : Le programme pingpong se termine-t-il ? </i>        </p>        <p> </p>        <h3></h3>        <h4>Les paramètres</h4>        <br>        <b> Modifiez le programme pingpong.c en ajoutant une fonction dont le          prototype est le suivant</b><br>        <br>        <pre>int psomme(int p1, int p2, int p3, int p4, int p5, int p6);</pre>        <p> Cette fonction doit retourner la valeur suivante : </p>        <pre>1*p1 + 2*p2 + 3*p3 + 4*p4 + 5*p5 + 6*p6</pre> <br>        <b> Dans le main remplacez l'appel à ping par un appel à psomme avec les          paramètres que vous voulez. Puis recompilez avec make pingpong.s </b><br>        <p> Les 4 premiers paramètres sont passés dans les registres <i><b>R0</b></i>          à <i><b>R3</b></i>. Les paramètres suivant sont passés dans la pile.        </p>        <br>        <b> Dans le fichier pingpong.s, observez l'appel à psomme. Dessinez la          pile au moment de l'instruction bl psomme <br>        </b>        <p> Comme vous pouvez le voir, la place pour stocker les paramètres dans          la pile a été prévu. L'espace utilisé dans la pile par chaque          fonction, que l'on appel une <b>frame</b> (d'où le registre FP, pour          Frame Pointer) peut donc contenir : </p>        <ul>          <li> L'adresse de retour LR si elle est écrasée par un appel de            fonction </li>          <li> Le registre FP si celui-ci est modifié par la fonction </li>          <li> Les registres utilisés par la fonction. <b>Notez que les              registres R0 à R3 ne sont sauvegardés que si ils contiennent des              paramètres. Dans le cas contraire, ils ne le sont pas car par              convention, ils servent uniquement au passage de paramètre. </b></li>          <li> Les variables locales </li>          <li> Les paramètres à transmettre à une fonction appelée lorsque le            nombre de paramètre dépasse 4. </li>        </ul>        <p></p>        <pre>         --------------SP -&gt;    | Variables  |         |  Locales   |         --------------         | Registres  |         |            |         --------------         |  FP        |         --------------FP -&gt;    |  LR        |         --------------         | Paramètres |         |  Effectifs |         --------------</pre>        <p> Quelques remarques:</p>        <ul>          <li>Cette utilisation de la pile n'est pas une convention absolue.            C'est un choix de GCC. </li>          <li>L'utilisation de pile peut légèrement varier en fonction des            paramètres d'optimisation de GCC, mais la convention d'appel de            fonction est toujours respectée.</li>        </ul>        <ul>          <li> Lorsque vous écrivez des programmes entièrement en assembleur,            vous pouvez choisir de suivre ou non cette convention. En revanche,            si vos programmes assembleurs sont destinés à être compilé avec des            programmes écrits en C, vous devez suivre cette convention pour des            raisons de compatibilité. Cela permet au code écrit à l'origine en C            d'appeler des fonctions écrites en assembleur, et inversement. </li>        </ul>        <h3></h3>        <h4>Observations avec GDB</h4>        <p>Soit le programme suivant:</p>        <code class="c"></code>        <h5>Fold6</h5>        <pre><code class="c">int fold2(int a, int b){    return a + b;}int fold3(int a, int b, int c){    return fold2(a, b) * c;}int fold6(int a, int b, int c, int d, int e, int f){    return fold3(a, b, c) - fold3(d, e, f);}int main(void){    int y = fold6(5, 3, 12, 43, 23, 21);    while(y);    return 0;}</code></pre><code class="c"></code>        <p> Essayez de dessiner la pile vant l'appel et au début de l'exécution          de chacune des trois fonctions <i>fold2</i>, <i>fold3</i> et <i>fold6</i>.</p>        <p>&nbsp; Pour vérifier vos prédictions, nous allons utiliser GDB pour          observer l'évolution de la pile.<br>          Le programmes ci-dessus a déjà été copié dans le fichier <i>fold6.c</i>.        </p>        <p> Le Makefile a été préparé pour obtenir l'assembleur (<i>fold6.s</i>)          et l'objet (<i>fold6.o</i>). Il ne vous reste plus qu'à modifier la          ligne de la règle <i>kernel.bin</i> avec le bon<i> .o</i> <br>        </p>        <b> Exécutez le programme pas à pas en observant la pile régulièrement          et vérifiez que cela correspond à vos prédictions. </b>        <p>N'oubliez pas d'utiliser le layout affichant le code assembleur. Vous          pourrez observer ce qu'il se passe avec plus de finesse. </p>        <p> Quelques astuces pour observer la pile :<br>        </p>        <ul>          <li> Afficher toute la pile à partir de SP: </li>        </ul>        <pre style="margin-left: 40px;">x/50xw $sp</pre>        <div style="margin-left: 40px;"> Remplacez 50 par le nombre de mot que          vous voulez afficher.</div>        <div style="margin-left: 40px;"><br>        </div>        <ul>          <li> Si vous voulez afficher un mot par ligne, utilisez </li>        </ul>        <pre style="margin-left: 40px;">x/1xw $sp</pre>        <div style="margin-left: 40px;"> Puis appuyez sur entrée autant de fois          que nécessaire. Pour afficher toute la pile à partir de SP, appuyez          sur entrée jusqu'à atteindre l'adresse 0x12000. </div>        <div style="margin-left: 40px;"><br>        </div>        <ul>          <li> Afficher la pile d'appel </li>        </ul>        <pre style="margin-left: 40px;">bt</pre>        <ul>          <li> N'oubliez pas de poser des breakpoints aux endroits qui vous            intéressent. </li>        </ul>        <p></p>        <div id="footer"> © UR IM2AG          <div id="bottom-links" style="float: right;"> <a href="../index.html">Home</a>          </div>        </div>      </div>    </div>  </body></html>