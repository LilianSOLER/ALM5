<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html lang="en-US">  <head>    <meta http-equiv="content-type" content="text/html; charset=utf-8">    <title>Workshop: Programming Basics</title>    <meta name="CHANGEDBY" content="Pr. Olivier Gruber">    <link rel="stylesheet" href="../style.css" type="text/css">    <script src="../common.js"></script>    <script src="../quizz.js"></script>    <link rel="stylesheet" href="../highlight.js/styles/default.css">    <script src="../highlight.js/highlight.pack.js"></script>    <script>hljs.initHighlightingOnLoad();</script>  </head>  <body onload="shellOnLoad()">    <script>      function shellOnLoad() {        multiLang();        /*hljs.initHighlightingOnLoad(); */        _quizzes = new Array();        parseQuizzes();      }      </script>    <div id="outer-container">      <div id="header">        <div id="logo"> <img src="../logo_uga.png" alt="Université Grenoble-Alpes"            height="100"            border="0">          <img src="../logo_reseau_polytech.gif" alt="Polytech" height="80" border="0">        </div>        <div id="top-links"> <a href="../index.html">Home</a> </div>      </div>      <div id="inner-container">        <h1>Les bases de l'assembleur<br>        </h1>        <h2>Task3 -- Utilisation de la mémoire<br>        </h2>        <h3>Step1 -- Les instructions d'accès à la mémoire<br>        </h3>        <span style="font-family: Arial,Serif;">L'accès à la mémoire n'est pas          la chose la plus simple avec le processeur ARM. Cela est dû à la          taille des instructions. Toutes les instructions du processeur ARM          sont sur 32 bits, soit 4 octets. Une adresse est codée sur au moins 32          bits, il est donc clairement impossible d'insérer une adresse dans une          instruction, l'instruction n'est tout simplement pas assez grande. <br>        </span>        <p>La solution utilisée dans le processeur ARM&nbsp; est de stocker dans          un registre l'adresse à laquelle on veut accéder, les intsructions<span            style="font-style: italic; font-weight: bold;">            ldr</span> et <span style="font-style: italic; font-weight: bold;">str
            </span>permettent ensuite d'accéder à la mémoire en lecture ou          écriture. Exemple:</p>        <pre><code class="arm"><br><br>	    ldr r1, [r0]<br>	    str r1, [r0]<br>	</code></pre>        <p>L'instruction <span style="font-style: italic; font-weight: bold;">ldr</span>          est destinée au chargement d'un registre depuis la mémoire. Dans          l'exemple, elle charge le registre <span style="font-style: italic; font-weight: bold;">r1</span>          avec la valeur des 4 cases mémoire se situant à partir de l'adresse          contenue dans <span style="font-style: italic; font-weight: bold;">r0</span>.        </p>        <p>Notez l'utilisation de crochets pour indiquer l'accès à la mémoire. </p>        <p>Supposons que r0 contienne la valeur X, à la suite de l'instruction <i>ldr
            r1, [r0]</i>, le registre r1 contiendra la valeur des 4 octets se          trouvant aux adresses X, X+1, X+2 et X+3. </p>        <pre><img src="AdresseAccesmemoire.png" alt="" style="width: 165px; height: 240px;"></pre>        <p>L'instruction <span style="font-style: italic; font-weight: bold;">str</span>          fonctionne symétriquement en écrivant la valeur contenue dans le          registre <span style="font-style: italic;">r1</span> en mémoire à          l'adresse contenue dans le registre <span style="font-style: italic;">r0</span>.        </p>        <p>Il reste à trouver le moyen de stocker une adresse de 32 bits dans un          registre. <br>        </p>        <p>L'instruction <span style="font-style: italic;">move reg, #imm</span>          permet de stocker une valeur immédiate dans un registre mais celle-ci          ne peut dépasser 8 bits. En fait c'est un peu plus compliqué (voir la          documentation sur ARM fournie section 1.4).</p>        <p>Il est possible de faire un calcul permettant de calculer une valeur          sur 32 bits à partir de morceaux sur 8 bits. La suite d'instruction          suivante stocke la valeur 0x12345678 dans le registre r0.</p>        <pre><code class="arm">	    mov r0, #0x12<br>	    lsl r0, #8<br>	    add r0,r0,#0x34<br>	    lsl r0, #8<br>	    add r0,r0,#0x56<br>	    lsl r0, #8<br>	    add r0,r0,#0x78</code></pre>        <p>l'instruction <span style="font-weight: bold; font-style: italic;">lsl
            r0, #8</span> décale à gauche de 8 bits la valeur de r0. </p>        <p>Au vue de la documentation ARM, écrivez un programme ARM équivalent          en seulement 4 instructions. <br>        </p>        <p>Dans tous les cas c'est un peu compliqué et de plus, il faudrait          connaitre explicitement l'adresse à manipuler. Hors nous ne la          connaissons pas quand nous écrivons le programme; l'adresse où sera          stocké le programme (et donc les variables) en mémoire n'est connue          qu'au moment de son exécution.<br>        </p>        <p> </p>        <p>Une idée simple est d'utiliser la valeur se trouvant dans le compteur          programme (<span style="font-style: italic; font-weight: bold;">pc</span>)          pour calculer l'adresse d'une étiquette se trouvant dans le programme.          Une variable peut être référencée par une étiquette à l'aide du mot <span            style="font-style: italic; font-weight: bold;">.word</span><br>        </p>        <p>Essayons le programme suivant: </p>        <pre><code class="arm"><br>	    ldr r0, [pc,#20]<br>	    ldr r1, [r0]<br>	    add r1, r1, #1<br>            str r1, [r0]<br>      var: .word 0x1234 </code></pre>        <br>        L'instruction <span style="font-style: italic;">ldr r0,[pc,#20]</span>        stocke dans le registre r0 la valeur se trouvant à l'adresse contenue        dans <span style="font-style: italic;">pc</span> + 20.        <p>La directive <span style="font-weight: bold; font-style: italic;">.word</span>          permet de mettre en mémoire une valeur sur 32 bits (ici 0x1234, en          hexadécimal) <br>        </p>        <p>Essayez&nbsp; d'exécuter les deux premières instructions. Le registre          r1 contient il la valeur se trouvant à l'étiquette <span style="font-style: italic;">var
            ?</span></p>        <p>Regarder la valeur de pc au moment de l'exécution de l'instruction <span            style="font-style: italic;">ldr
            r0,[pc,#20]</span></p>        <p><span style="font-style: italic;"><b>Attention</b>: Le debugueur            donne pour la valeur de pc, l'adresse de l'instruction qui va être            exécutée.</span></p>        <p><span style="font-style: italic;">En fait ce n'est pas tout à fait            vrai....</span></p>        <p><span style="font-style: italic;"><br>          </span></p>        <p> </p>        <p>En fait, le compteur de programme est toujours en avance lors de          l'exécution d'une instruction. Cela est dû à la constuction du          processeur ARM qui permet d'exécuter les instructions en <span style="font-style: italic; font-weight: bold;">pipeline</span>.        </p>        <p>Rappelez-vous notre métaphore de la cuisine? Le chef est le          processeur, son assistant est le bus système. Imaginez que notre chef          a besoin de couper les oignons et les carottes. D'abord, il demande à          son assistant d'aller chercher les oignons. Le chef doit attendre que          l'assistant revienne avec les oignons avant de pouvoir commencer à les          couper. Mais alors qu'il coupe les oignons, il peut demander à          l'assistant d'aller chercher les carottes. C'est le principe du          pipeline, une technique utilisée dans la plupart des chaînes de          montage dans les usines du monde entier. Les processeurs font la même          chose. </p>        <p>Le processeur ARM a un pipeline qui comporte trois étapes:          extraction, décodage et exécution. <span style="font-family: Helvetica,Arial,sans-serif;">L'étape
            d'extraction char</span>ge la prochaine instruction de la mémoire,          en utilisant le compteur de programme. L'étape de décodage consiste à          décoder l'instruction, en comprenant quelle instruction elle est. La          dernière étape concerne l'exécution proprement dites de l'instruction.          <br>        </p>        <p>Donc au moment où le processeur exécute le <span style="font-style: italic;">ldr</span>,          il charge déjà l'instruction <span style="font-style: italic;">add</span>,          pc "pointe" déjà deux instructions plus loin.<br>        </p>        <p>Essayez donc le programme corrigé:<br>        </p>        <pre><code class="arm"><br></code><code class="arm">     </code><code class="arm">       ldr r0, [pc,#8]<br>	    ldr r1, [r0]<br>	    add r1, r1, #1<br>            str r1, [r0]<br>      var: .word 0x1234 </code><codeclass="arm"><br>	<br><br><br></code><big><spanstyle="font-family: Helvetica,Arial,sans-serif;">Nous savons maintenant accéder à n'importe quelle case de la mémoire.</span></big></pre>        <div id="footer"> © UFR IM2AG          <div id="bottom-links" style="float: right;"> <a href="../index.html">Home</a>          </div>        </div>      </div>    </div>  </body></html>