<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html lang="en-US">  <head>    <meta http-equiv="content-type" content="text/html; charset=utf-8">    <title>Workshop: Programming Basics</title>    <meta name="CHANGEDBY" content="Pr. Olivier Gruber">    <link rel="stylesheet" href="../style.css" type="text/css">    <script src="../common.js"></script>    <script src="../quizz.js"></script>    <link rel="stylesheet" href="../highlight.js/styles/default.css">    <script src="../highlight.js/highlight.pack.js"></script>    <script>hljs.initHighlightingOnLoad();</script>  </head>  <body onload="shellOnLoad()">    <script>      function shellOnLoad() {        multiLang();        /*hljs.initHighlightingOnLoad(); */        _quizzes = new Array();        parseQuizzes();      }      </script>    <div id="outer-container">      <div id="header">        <div id="logo"> <img src="../logo_uga.png" alt="Université Grenoble-Alpes"            border="0"            height="100">          <img src="../logo_reseau_polytech.gif" alt="Polytech" border="0" height="80">        </div>        <div id="top-links"> <a href="../index.html">Home</a> </div>      </div>      <div id="inner-container">        <h1>Sprint: Assembly Programming Basics</h1>        <h2>Task4 -- Gestion de la pile</h2>        <h3>Step 5 -- Travail Pratique : La pile en C</h3>        <p>Afin de vérifier si vous avez compris l'ensemble des notions autour          des fonctions et de la pile, vous allez réaliser ce TP et rendre un          compte rendu.</p>        <p> Le TP consiste en deux parties :<br>          1) Observer du code assembleur, observer son exécution sous GDB et à          répondre à un certain nombre de questions. <br>          2) Des exercices de programmation au choix. </p>        Placez vous dans le répertoire task4s5C.<br>        Compilez le programme pgcd.c en utilisant la commande <i>make</i> puis        ouvrez les fichier pgcd.c et pgcd.s pour observer ce que GCC a généré        comme assembleur.<br>        <h4>Questions d'analyse</h4>        <p> Exécutez le programme sous GDB en vous arrêtant aux bons endroits en          en observant les variables, les registres, la pile .... </p>        <p> </p>        <ol>          <li>A quelle adresse commence la pile ? comment le savez-vous ?</li>          <li>Dessinez l'état de la pile après la deuxième instruction du <i>main</i>            (<i>add fp, sp, 4</i>).</li>          <li>Donnez la valeur (en hexadécimal) de fp et sp à ce moment là.</li>          <li>Où sont stockées les trois variables locales du main: <i>x</i>, <i>y</i>            et <i>res</i> ?</li>          <li>Dessinez la pile après l'initialisation de&nbsp; <i>x</i> et <i>y</i>.            On précisera les emplacements des variables par rapport à <i>fp</i>.</li>          <li>Comment sont passés les trois paramètres effectifs de la fonction            <i>pgcd</i> ? </li>          <li>Donnez la valeur de ces trois paramètres,en particulier &amp;res.</li>          <li>Donnez l'adresse en mémoire de la variable <i>res</i> (en            hexadécimal). </li>          <li>Dessinez l'état de la pile une fois dans la fonction pgcd (après            l'instruction <i>add fp, sp, 4)</i></li>          <li>Expliquez les trois dernières instructions de la fonction <i>pgcd</i>            (<i>sub, pop</i> et <i>bx</i>). </li>          <li>Pourquoi les paramètres sont ils stockés ensuite sur la pile ?</li>          <li>Expliquez l'instruction <i>str fp, [sp,#-4]!</i></li>          <li>Dessinez l'état de la pile une fois que l'on se trouve dans la            fonction <i>restediv</i>.</li>          <li>Expliquez pourquoi le registre <i>lr</i> n'est pas sauvegardé sur            la pile dans cette fonction.</li>          <li>Expliquez comment est traduite en assembleur la boucle <i>while</i>            se trouvant dans la fonction <i>restediv</i>.</li>          <li>Comment est retournée la valeur résultante de la fonction <i>restediv
              </i>?</li>          <li>Comment est traduite l'instruction <i>*resultat = b</i> dans la            fonction <i>pgcd </i>?</li>          <li>Retrouvez en affichant sous gdb la pile à ce moment là, la valeur            et l'adressede la variable<i> res</i>.</li>          <li>Où retrouve t on dans l'assembleur le passage des 3 paramètres            effectifs (<i>b, reste</i> et <i>resultat</i>) de l'appel récursif            de<i> pgcd ?</i></li>          <li>Pourquoi dans le programme C ce n'est pas l'adresse de la variable            <i>resultat</i> <i>(&amp;resultat) </i>qui est passé lors de cet            appel de <i>pgcd ?</i></li>          <li>Vérifiez sous gdb que c'est bien toujours l'adresse de la variable            <i>res</i> du <i>main</i> qui est passée en paramètre lors de ce            deuxième appel de <i>pgcd</i>.</li>          <li>Dessinez l'état de la pile après ce deuxième appel de la fonction            de<i> pgcd.</i></li>          <ol>          </ol>        </ol>        <ol>          <ol>          </ol>        </ol>        <span style="font-family: serif;"></span>        <p><br>        </p>        <ol>        </ol>        <p></p>        <h4>Exercices de programmation</h4>        <p> Réalisez les exercices de programmations ci-dessous. Il ne vous est          <b>pas demandé de tous les faire</b>, seulement <b>au moins un            exercice en assembleur ARM, et un en C</b>. Choisissez ceux qui vous          inspirent le plus. Les exercices sont classés par ordre de difficulté.        </p>        <p> </p>        <h5>Exercice 1 (ARM) : print_string</h5>        Ecrivez en assembleur ARM, une fonction <b>print_string</b> qui prend        en paramètre une adresse d'une chaîne de caractère (par le registre r0),        et l'affiche. <br>        Vous devrez utiliser la fonction <b>_writec</b> contenue dans le        fichier <i>io.s</i>. <br>        Voici un exemple d'utilisation de la fonction.        <p></p>        <pre><code class="arm">_start:    ldr r0, .string_ptr    bl print_string/*...*/.string_ptr:    .word stringstring:    .ascii "HELLO WORLD!\000"        </code></pre>        <p> Comme vous pouvez le constater, la chaîne de caractère termine avec          <b><i>"\000"</i></b>. Cela sert à repérer la fin de la chaîne en la          terminant par un 0. </p>        <p> </p>        <h5>Exercice 2 (C) : print_string</h5>        Même exercice que l'exercice 1 mais en C.        <p></p>        <p> </p>        <h5>Exercice 3 (ARM) : console</h5>        Ecrivez un programme qui permet à l'utilisateur de saisir du texte dans        le terminal de qemu. Le texte saisie par l'utilisateur doit s'afficher à        l'écran en temps réel. <br>        Lorsque l'utilisateur appuie sur entrée, le programme affiche sur une        nouvelle ligne, le texte saisie en majuscule. Si le texte contient des        caractères qui ne sont pas des lettres, elles ne doivent pas être        modifiées.<br>        Exemple d'affichage du programme :        <p></p>        <pre><code>je suis dans la console qemuJE SUIS DANS LA CONSOLE QEMUJe Peux saisir DU texteJE PEUX SAISIR DU TEXTEQu1 c0nt13nt De5 ch1ffres et De5 Lettr3sQU1 C0NT13NT DE5 CH1FFRES ET DE5 LETTR3S        </code></pre>        <p> Vous aurez besoin des fonctions <b><i>_wirtec</i></b> et <b><i>_readc</i></b>          du fichier <i>io.s</i> </p>        <p> </p>        <h5>Exercice 4 (C) : console</h5>        Même exercice que l'exercice 3 mais en C.        <p></p>        <p> </p>        <h5>Exercice 5 (ARM) : print_hex</h5>        Ecrivez une fonction <b>print_hex</b> qui prend en entrée un entier        (dans le registre r0) et affiche son contenu sous forme hexadecimal.        Exemple (0x003FA6EC). Affichez les 0 de telle sorte que le nombre total        de caractère soit toujours 8 (les registres font 32 bits).        <p></p>        <p> </p>        <h5>Exercice 6 (C) : print_hex</h5>        Même exercice que l'exercice 5 mais en C.        <p></p>        <p> </p>        <h5>Exercice 7 : Exercice libre</h5>        Pour les plus motivés, réalisez le programme que vous voulez en        respectant les règles suivantes :        <ol>          <li>Il doit contenir un mélange d'assembleur ARM et de C. Vous êtes            libre de choisir les proportions de C et d'assembleurs, l'important            est d'être capable d'écrire des fonctions dans un language,            utilisées dans un autre.</li>          <li>Il doit être interractif. L'utilisateur doit saisir du texte ou            commander le programme au clavier.</li>          <li>Il doit être commenté le mieux possible. Sans fournir une            documentation complète, un minimum de commentaires sont demandés            pour aider à la navigation dans le code.</li>        </ol>        Soyez créatifs, et surtout, amusez vous !        <p></p>        <div id="footer"> © UFR IM2AG          <div id="bottom-links" style="float: right;"> <a href="../index.html">Home</a>          </div>        </div>      </div>    </div>  </body></html>