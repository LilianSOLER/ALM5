<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html lang="en-US">  <head>    <meta http-equiv="content-type" content="text/html; charset=utf-8">    <title>Workshop: Programming Basics</title>    <meta name="CHANGEDBY" content="Pr. Olivier Gruber">    <link rel="stylesheet" href="../style.css" type="text/css">    <script src="../common.js"></script>    <script src="../quizz.js"></script>    <link rel="stylesheet" href="../highlight.js/styles/default.css">    <script src="../highlight.js/highlight.pack.js"></script>    <script>hljs.initHighlightingOnLoad();</script>  </head>  <body onload="shellOnLoad()">    <script>      function shellOnLoad() {        multiLang();        /*hljs.initHighlightingOnLoad(); */        _quizzes = new Array();        parseQuizzes();      }      </script>    <div id="outer-container">      <div id="header">        <div id="logo"> <img src="../logo_uga.png" alt="Université Grenoble-Alpes"            border="0"            height="100">          <img src="../logo_reseau_polytech.gif" alt="Polytech" border="0" height="80">        </div>        <div id="top-links"> <a href="../index.html">Home</a> </div>      </div>      <div id="inner-container">        <h1>Sprint: Assembly Programming Basics</h1>        <h2>Task4 -- Gestion de la mémoire sous la forme d'une pile</h2>        <h3>Step2 -- La Solution </h3>        <p>On peut définir deux instructions <em style="font-weight: bold;">push</em>:          empilement en mémoire, et <em style="font-weight: bold;">pop</em>:          dépilement. <br>        </p>        <p>Nous verrons par la suite que ces deux instructions sont des alias          d'instructions que nous connaissons déjà.</p>        <p>On peut reécrire la fonction factorielle:<br>        </p>        <pre><code class="arm"><br>/*<br> * Factorial function: the argument n in r0<br> * Returns the computed result in r0<br> * Clobbers r0 and r1.<br> */<br>.align 2<br>.global _fact<br>	.type _fact,%function<br>	.func _fact,_fact<br>_fact:<br>	cmp r0, #1       // fact(1)=1<br>	bne .L0          // so if r0==1<br>	mov pc, lr       // return 1<br>.L0:<br>	push {r1}        // save r1 in memory on the stack<br>	move r1, r0	 // save r0 in r1<br>	sub r0,r0,#1     // compute (n-1)!<br>        bl _fact         // by recursively calling  _fact<br>	mul r0, r1, r0   // compute n*(n-1)!<br>        pop {r1}	 //restore r1<br>	<br>	mov pc,lr        // return<br>	.size	_fact, .-_fact<br>	.endfunc <br>	</code></pre>        <p>Essayons ce code pour comprendre comment se passe l'empilement et le          dépilement. </p>        <p>Créez un fichier source <span style="font-style: italic;">fact.s</span>          et intégrez-le dans le Makefile, comme nous l'avons déjà fait pour le          <span style="font-style: italic;">sum.s</span>. Compilez ce code et          corrigez-le en définissant un point d'arrêt dans <span style="font-style: italic;">_fact</span>.        </p>        <p>Pour faire simple, on peut initialiser dans gdb le registre <i>pc</i>          à l'étiquette <span style="font-style: italic;">_fact</span> (sous          entendu l'adresse) et même le registre <span style="font-style: italic;">r0</span>          pour donner une valeur au paramètre de fact (on va calculer ici 3!).</p>        <p>Le registre <span style="font-style: italic; font-weight: bold;">sp</span>          (<span style="font-style: italic; font-weight: bold;">Stack Pointer</span>)          a une fonctionnalité très particulière, il va contenir à tout moment          le sommet de la pile. On l'intialise ici à <i>0xFF</i>. <br>        </p>        <textarea class="terminal" rows="10">  $ make gdb  ...  (gdb) br _fact  (gdb) set $pc = _fact  (gdb) set $sp = 0xFF  (gdb) set $r0 = 3  (gdb) layout next  (gdb) layout next	</textarea>        <p>Vous devriez avoir à l'écran les instructions assembleur avec la          traduction des alias <i>push</i> et <i>pop</i> qui utilise le          registre <span style="font-style: italic; font-weight: bold;">sp</span>.<br>        </p>        <span style="font-family: Arial,Serif;"><br>          <br>          <span style="font-weight: bold;">L'empilement:</span><br>        </span>        <pre><code class="arm"><br>	    push   {r1}            ; (str r1, [sp, #-4]!)    <br>	</code></pre>        <p>On stocke la valeur de <i>r1</i> à l'adresse qui est dans <span style="font-style: italic;">sp</span>          à laquelle on a soustrait 4 (car un registre est sur 4 octets).<br>          <span style="font-style: italic;">sp</span> contenant l'adresse du          dernier élement empilé, on stocke ainsi <i>r1</i> sur la pile.</p>        <p>Le point d'interrogation signifie que <span style="font-style: italic;">sp</span>          est modifié et prend donc la valeur de <span style="font-style: italic;">sp-4</span>          pendant cette instruction.<br>        </p>        <p>On peut traduire cette instruction par ces deux instructions:</p>        <pre><code class="arm">	sub sp, #-4<br>	str r1, [sp]<span style="font-family: Arial,Serif;"><spanstyle="font-weight: bold;"><br><br></span></span></code></pre>        <p style="font-weight: bold;">Le dépilement: </p>        <pre><code class="arm">   	pop    {r1}            ; (ldr r1, [sp], #4)    </code></pre>        <p>Cette fois ci le dernier élement de la pile est dépilé dans <i>r1</i>.          Le registre <span style="font-style: italic;">sp</span> doit être          ensuite incrémenté de 4 pour qu'il pointe sur l'élément précédemment          empilé.</p>        <p>On peut traduire cette instruction par ces deux instructions: </p>        <pre><code class="arm"><br>	    ldr r1, [sp]<br>	    add sp, sp, #4<br>	</code></pre>        <p>Maintenant faisons tourner le programme en pas à pas. On peut          visualiser le contenu de <span style="font-style: italic;">sp</span>          à tout moment par : </p>        <textarea class="terminal" rows="5">	  (gdb) disp /x $sp	  (gdb) si	  1: /x $sp = 0xff	  (gdb)	</textarea>        <p>Pour bien comprendre l'évolution de la pile, il faut regarder          l'évolution de la mémoire avant l'adresse <i>0xFF</i> avant et après          les instructions <i>pop</i> et <i> push</i>. </p>        <textarea class="terminal" rows="6">	  (gdb) si	  1: /x $sp = 0xfb	  (gdb) x /4xb 0xfb	  0xfb: 0x03 0x00 0x00 0x00	  (gdb)	</textarea>        <p>Rappelez vous <span style="font-style: italic; font-weight: bold;">x            /4xb 0xb</span> visualise en hexadécimal les 4 octets se trouvant en          mémoire à partir de l'adresse <span style="font-style: italic;">0xfb</span>.        </p>        <p>On peut aussi regarder la valeur sur 4 octets se trouvant en <span style="font-style: italic;">0xfb</span>          comme ceci: </p>        <textarea class="terminal" rows="4">	  (gdb) x /1xw 0xfb	  0xfb: 0x00000003	  (gdb)	</textarea>        <p>Pour arriver à comprendre les empilements/dépilement successifs,          exécutez en pas à pas la fonction <span style="font-style: italic;">fact</span>          et dessinez sur un papier les états successifs de la pile, c'est à          dire les valeurs se trouvant en mémoire avant l'adresse 0xFF.</p>        <img src="pilememoire.png" width="100%">        <p><br>        </p>        Nous sommes arrivés à un moment crucial de la compréhension de        l'exécution de tous les programmes que vous écrirez plus tard et cela        quel que soit le langage de programmation. Le concept de pile vous        poursuivra toute votre vie d'informaticien. <br>        <br>        Prenez donc le temps qu'il faudra, mais ne baclez pas cette étape        difficile.        <p><br>          <br>          Pour finir, il faut savoir qu'il est possible d'empiler/dépiler          plusieurs registres en une seule instruction. Par exemple <span style="font-style: italic; font-weight: bold;">pop
            {r0, r1, r5}</span></p>        <br>        <br>        <br>        <div id="footer"> © UFR IM2AG&nbsp; <br>          <div id="bottom-links" style="float: right;"> <a href="../index.html">Home</a>          </div>        </div>      </div>    </div>  </body></html>