<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html lang="en-US">  <head>    <meta http-equiv="content-type" content="text/html; charset=utf-8">    <title>Workshop: Programming Basics</title>    <meta name="CHANGEDBY" content="Pr. Olivier Gruber">    <link rel="stylesheet" href="../style.css" type="text/css">    <script src="../common.js"></script>    <script src="../quizz.js"></script>    <link rel="stylesheet" href="../highlight.js/styles/default.css">    <script src="../highlight.js/highlight.pack.js"></script>    <script>hljs.initHighlightingOnLoad();</script>  </head>  <body onload="shellOnLoad()">    <script>      function shellOnLoad() {        multiLang();        /*hljs.initHighlightingOnLoad(); */        _quizzes = new Array();        parseQuizzes();      }      </script>    <div id="outer-container">      <div id="header">        <div id="logo"> <img src="../logo_uga.png" alt="Université Grenoble-Alpes"            border="0"            height="100">          <img src="../logo_reseau_polytech.gif" alt="Polytech" border="0" height="80">        </div>        <div id="top-links"> <a href="../index.html">Home</a> </div>      </div>      <div id="inner-container">        <h1>Sprint: Assembly Programming Basics</h1>        <h2>Task4 -- La gestion de la mémoire dans une fonction</h2>        <h3>Step 1 - Le problème</h3>        <p>Dans la première fonction que nous avons écrite (une division entière          dans la tâche 2, step1) nous n'avons pas fait d'accès mémoire,          l'adresse de retour, les paramètres de la fonction et les résultats          intermédiaires étaient stockés dans des registres:</p>        <pre><code class="arm">/* Fonction qui calcule la division entière */<br>/* Le dividende est donne dans r0,</code><codeclass="arm">le diviseur dans r1*/</code><br><codeclass="arm">/* le quotient est retourne dans r0, le reste dans r2*/<br><br>.text<br>	.align 2<br>.global _div<br>	.type _div,%function<br>	.func _div,_div<br>_div:<br>	mov r2, #0<br>.L1:<br>	cmp r0, r1<br>	blt .L2<br>	add r2,r2,#1<br>	sub r0, r0, r1<br>	b .L1<br>.L2:<br>	mov pc,lr<br>	.size	_div, .-_div<br>	.endfunc <br><br></code></pre>        <p>Le registre <i>r2</i>&nbsp; est peut être utilisé par le programme          qui appelle la fonction (l'appelant). Sa valeur est écrasé lors de          l'appel de la fonction. Il faut donc prendre des précautions avant          d'utiliser la fonction. Si l'on veut rendre indépendante la fonction          lors de son utilisation, c'est à dire que l'appelant n'est pas à se          soucier des registres utilisés, le plus simple est de sauvegarder les          registres dans la fonction avant leur utilisation et de restaurer          leurs valeurs avant le retour de la fonction.</p>        <p>Cette sauvegarde doit être fait en mémoire. Elle pourrait être fait          dans des cases mémoires prévues dans le programme au moment de          l'utilisation d'un registre dans la fonction comme ceci:<br>        </p>        <br>        <pre><code class="arm">.text<br>	.align 2<br>.global _div<br>	.type _div,%function<br>	.func _div,_div<br>_div:<br>	ldr r10, =sauv_r2  //r10 contient l'adresse correspondant a l'etiquette sauv_r2<br>	str r2 [r10]   //sauvegarde de r2 en memoire<br>	mov r2, #0<br>.L1:<br>	cmp r0, r1<br>	blt .L2<br>	add r2,r2,#1<br>	sub r0, r0, r1<br>	b .L1<br>.L2:<br>	ldr r10, =sauv_r2<br>	ldr r2,[r10]   //restauration de r2 avant le retour<br>	mov pc,lr<br>	.size	_div, .-_div<br>	.endfunc <br><br>.data<br>sauv_r2:.word 0x0<br></code></pre>        <p>On peut remarquer que pour sauvegarder <i>r2</i>, il a fallu se          servir d'un autre registre (r10), c'est le serpent qui se mord la          queue, il faudrait aussi le sauvegarder avant son utilisation. On          peut, pour résoudre le problème réserver un registre pour cette seule          utilisation.</p>        <p>A remarquer au passage qu'il faudrait aussi sauvegarder l'adresse de          retour (qui est dans le registre&nbsp; <span style="font-style: italic;">lr</span>)&nbsp;
          si la fonction refaisait un deuxième appel de fonction (appel          imbriqué). On reviendra sur ce problème par la suite.<br>        </p>        <p style="font-weight: bold;">Le problème de la récursivité:</p>        <p>Mais que se passe t-il si l'on a une fonction qui s'appelle elle même          (fonction <span style="font-weight: bold;">récursive</span>) ? </p>        <p>Les cases mémoires de sauvegardes des registres sont écrasées lors du          deuxième appel de la fonction puisque une seule case mémoire est          réservée pour la sauvegarde des registres.</p>        <p>Cela ne marche plus :-(</p>        <p>Prenons comme exemple le calcul de la factoriel d'un entier n: </p>        <pre>	  n! = n * (n-1) * (n-2) * ... * 1<br>	</pre>        <p>Cette fonction se prête à merveille à la récursivité puisque </p>        <pre><br>	  n! = n * (n-1)!<br>	</pre>        <p>On peut l'écrire tout d'abord en langage C: </p>        <pre><br><code><br>int fact(int n) <br>{<br>  if (n==1)<br>    return 1;<br><br>  return n*fact(n-1);<br>}<br>	</code></pre>        <p>Une première traduction en assembleur: </p>        <pre><code class="arm"><br>/*<br> * Factorial function: the argument n in r0<br> * Returns the computed result in r0<br> * Clobbers r0 and r1.<br> */<br>.align 2<br>.global _fact<br>	.type _fact,%function<br>	.func _fact,_fact<br>_fact:<br>	cmp r0, #1       // fact(1)=1<br><br>	bne .L0          // so if r0==1<br>	mov pc, lr       // return 1<br><br>.L0:<br>	ldr r10,=sauv_r1<br>	str r1, [r10]	 // save r1 in memory<br>	mov r1, r0       // save r0 in r1<br>	sub r0,r0,#1     // compute (n-1)!<br>	bl _fact         // by recursively calling  _fact<br>	mul r0, r1, r0   // compute n*(n-1)!<br><br>	ldr r10,=sauv_r1<br>	ldr r1 , [r10]   // restore r1<br> 	<br>	mov pc,lr        // return<br><br> .ltorg<br>	.size	_fact, .-_fact<br>	.endfunc <br>.data:<br>	sauv_r1:.word 0x0<br>	sauv_lr:.word 0x0<br>	</code></pre>        <p>Que se passe t-il si l'on fait tourner ce programme ? </p>        <span style="font-family: Arial,Serif;">La sauvegarde de <i>r1</i> est          écrasée dès le deuxième appel de la fonction.<br>          Il faudrait une case mémoire différente pour chaque appel de la          fonction. On ne connait pas à l'avance le nombre d'appel....Dur dur !<br>          <br>          On invente la <b>pile</b>: une zone mémoire où l'on va          sauvegarder/restaurer successivement les registres nécéssaires. <br>          Attention les dernières valeurs sauvegardées doivent être restaurées          en premier. <br>          De la même façon que lorsque on pose des assiettes sur une pile, la          première enlevée de la pile sera la dernière posée.<br>          <br>          La figure suivante montre l'empilement successif (<i>pushing</i>)          jusqu'au dernier appel (n=1) et les dépilements successifs (<i>popping</i>).</span><br>        <br>        <img src="callstack.png" width="100%"><span style="font-family: Arial,Serif;"><br>          <br>          <br>          Comment arriver à gérer ces sauvegardes de cette manière ?<br>        </span>        <div id="footer"> © UFR IM2AG          <div id="bottom-links" style="float: right;"> <a href="../index.html">Home</a>          </div>        </div>      </div>    </div>  </body></html>