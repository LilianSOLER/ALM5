<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html lang="en-US">  <head>    <meta http-equiv="content-type" content="text/html; charset=utf-8">    <title>Workshop: Programming Basics</title>    <meta name="CHANGEDBY" content="Pr. Olivier Gruber">    <link rel="stylesheet" href="../style.css" type="text/css">    <script src="../common.js"></script>    <script src="../quizz.js"></script>    <link rel="stylesheet" href="../highlight.js/styles/default.css">    <script src="../highlight.js/highlight.pack.js"></script>    <script>hljs.initHighlightingOnLoad();</script>  </head>  <body onload="shellOnLoad()">    <script>      function shellOnLoad() {      multiLang();      /*hljs.initHighlightingOnLoad(); */      _quizzes = new Array();      parseQuizzes();      }      </script>    <div id="outer-container">      <div id="header">        <div id="logo"> <img src="../logo_uga.png" alt="Université Grenoble-Alpes"            border="0"            height="100">          <img src="../logo_reseau_polytech.gif" alt="Polytech" border="0" height="80">        </div>        <div id="top-links"> <a href="../index.html">Home</a> </div>      </div>      <div id="inner-container">        <h1>Sprint: Assembly Programming Basics</h1>        <h2>Task3 -- Utilisation de la mémoire</h2>        <h3>Step7 -- L'ordre en mémoire :&nbsp; gros ou petit bout</h3>        <h3> </h3>        <p>Nous avons appris comment charger une adresse, en utilisant le          registre <span style="font-style: italic;">pc</span> (<span style="font-style: italic;">r15</span>),
          et ensuite utiliser cette adresse pour charger ou stocker des valeurs          en mémoire. Nous l'avons fait avec des valeurs de 32 bits,          c'est-à-dire 4 octets. </p>        <p>Il est aussi possible de lire et écrire des valeurs stockées dans un          seul octet et même 2 octets : </p>        <pre><code class="arm"></code><code class="arm"><br>	   &nbsp;ldrb r3,[r0]  // loads a byte, in the first 8 bits of r3.<br>	    ldrh r3,[r0]  // loads two bytes, in the first 16 bits of r3.<br>	    ldr  r3,[r0]  // loads four bytes, in the 32 bits of r3.<br>	  <br>	</code></pre>        <p>L'instruction <span style="font-style: italic; font-weight: bold;">ldrb</span>          (b comme byte) charge un seul octet dans l'octet de poids faible du          registre destination, les trois autres octets sont mis à 0. De même <span            style="font-weight: bold; font-style: italic;">ldrh</span>          (h comme half word) charge deux octets dans les deux octets de poids          faible. <br>        </p>        <p>De la même façon il existe les instructions d'écriture en mémoire          d'un seul octet et deux octets: <span style="font-style: italic; font-weight: bold;">strb</span>          et <span style="font-style: italic; font-weight: bold;">strh</span><br>        </p>        <p>Rappel: l'octet de <span style="font-weight: bold;">poids faible</span>          est l'octet qui est le plus à droite lors de l'écriture          conventionnelle de gauche à droite. <br>        </p>        <p>Exemple : dans 0x1234 l'octet de poids faible a pour valeur 0x34<br>        </p>        <p>Essayez sous <span style="font-style: italic;">gdb</span> le          programme suivant (<i>task3/startbis.s</i>) en pas à pas:<code class="arm"></code><br>        </p>        <pre><code class="arm"><br></code><code class="arm"></code><code class="arm">	mov r0, pc<br>	b  .L1<br>var: 	.word 0x12345678    <br></code><codeclass="arm">.L1:</code><codeclass="arm">  	ldrb r3,[r0]  // loads a byte, in the first 8 bits of r3.<br>	ldrh r3,[r0]  // loads two bytes, in the first 16 bits of r3.</code></pre>        <p>Observez la valeur de r3 après le <span style="font-style: italic;">ldrb</span>.          Est ce 0x78 ou 0x12 ? <br>        </p>        <p>Cela vous parait il normal ?</p>        <p>Regardons le contenu de la mémoire qui se trouve à l'étiquette <span            style="font-style: italic;">var</span>.<br>        </p>        <p>La commande <span style="font-style: italic;">e</span><span style="font-weight: bold; font-style: italic;">X</span><span            style="font-style: italic;">amine</span>          de gdb permet d'observer le contenu de la mémoire dans un format          désiré composé de 3 lettres "/ <span style="font-weight: bold; font-style: italic;">xyz</span>".
          <br> </p>        <p>Le 'z' donne la taille de l'entité: b pour l'octet, h pour le          demi-mot, w pour le mot. <br>        </p>        <p>Le 'y' donne le format à utiliser pour imprimer les valeurs: x pour          hexa, d pour decimal, a pour l'adresse, c pour le caractère. <br>        </p>        <p>Le 'x' est le nombre d'entités que vous voulez voir. <br>        </p>        <p>Exemples:</p>        <textarea class="terminal" rows="5">	  (gdb) x /1xw 0x10034	  0x10034: 0x12345678	  (gdb) x /4xb $r1	  0x10034: 0x78 0x56 0x34 0x12	</textarea> La première commande affiche 1 seul mot en hexadécimal stocké à        l'adresse 0x10034.<br>        <br>        La deuxième commande affiche les 4 octets, en hexadécimal stockés à        partir de l'adresse 0x10034.&nbsp; Les octets sont donnés dans l'ordre        croissant des adresses, c'est à dire:<br>        <table>          <tbody>            <tr>              <th>address</th>              <th>value</th>            </tr>            <tr>              <th>0x10034</th>              <th>0x78</th>            </tr>            <tr>              <th>0x10035</th>              <th>0x56</th>            </tr>            <tr>              <th>0x10036</th>              <th>0x34</th>            </tr>            <tr>              <th>0x10037</th>              <th>0x12</th>            </tr>          </tbody>        </table>        <p>&nbsp;Si vous oubliez les détails d'une commande dans gdb, demandez à          gdb de vous aider:</p>        <textarea class="terminal" rows="4">	  (gdb) help x 	  Examine memory: x/FMT ADDRESS.	  ...	</textarea>        <p>L'ordre de stockage des octets en mémoire (poids fort ou poids faible          en premier) n'est qu'une convention. Pour faire simple, tous les          processeurs n'ont pas été conçu avec la même convention. Le processeur          ARM est un processeur petit boutiste (<span style="font-style: italic; font-weight: bold;">little
            endian</span>), il stocke l'octet de poids faible en premier. <br>        </p>        <p>Vous pouvez lire l'excellent article de Wikipédia sur ce sujet: <a href="https://en.wikipedia.org/wiki/Endianness">Wikipedia
            article</a> </p>        <p>Pour vous conforter dans la compréhension de ce phénomène, essayez le          programme suivant en pas à pas en essayant de deviner le contenu de la          mémoire avant de l'examiner à l'aide de gdb: </p>        <pre><code class="arm"><br>            // assume that r0 contains 0x12345678<br>            mov r2,#0<br>	    sub r2,r2,#1<br>	    // now r2 has the value 0xFFFFFFFF<br>	    mov r1, pc<br>	    b   .L1<br>	    .word 0x00000000<br>	    .L1:<br>	    str r0,[r1]<br>	    // (gdb) x /4xb $r1<br>	    str r2,[r1]<br>	    // (gdb) x /4xb $r1<br>	    strb r0,[r1]<br>	    // (gdb) x /4xb $r1<br>	    str r2,[r1]<br>	    // (gdb) x /4xb $r1<br>	    strh r0,[r1]<br>	    // (gdb) x /4xb $r1<br>	</code></pre>        <br>        <div id="footer"> © UFR IM2AG &nbsp;          <div id="bottom-links" style="float: right;"> <a href="../index.html">Home</a>          </div>        </div>      </div>    </div>  </body></html>