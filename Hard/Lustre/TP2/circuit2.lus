--Circuit additionneur 1 bit
--résultat z
--c1 est C+1 retenu
function add1bit (a, b, cin : bool) returns (z, c1 : bool);
let
	z = a xor (b xor cin) ; -- calcule le résultat
	c1 = (a and b) or (b and cin) or (a and cin) ; --calcule la retenue
tel;

--Circuit additionneur n bit
--résultat R
--cout est la retenu
function addnbits <<const n: int>>(A , B : bool^n ; cin : bool)
returns (R : bool^n ; cout,c1 : bool);
var retint: bool^n+1;
let
retint[0]= cin;
--réalise n fois l'addition 1 bit avec A,B et la sortie du précédent en entrée (ou cin en entrée)
(R, retint[1..n])= map<<add1bit, n >>( A, B, retint[0..n-1]);
cout= retint[n];
c1= retint[n-1];
tel;

--instancie l'additionneur n bits avec n = 4
function add4= addnbits<<4>>;

--Circuit soustracteur 1 bit
--resultat d
--retenu t1
function sub1bit (a, b, c : bool) returns (t1, d : bool);
var t0: bool;
let
(t0, d) = add1bit(a, not b, not c);
t1 = not t0;
tel;

--Circuit soustracteur n bit
--résultat R
--cout est la retenu
function subnbits <<const n: int>>(A , B : bool^n ; cin : bool)
returns (R : bool^n ; cout : bool);
var retint: bool^n+1;
let
retint[0]= cin;
--réalise n fois la soustraction 1 bit avec A,B et la sortie du précédent en entrée (ou cin en entrée)
(R, retint[1..n])= map<<sub1bit, n >>( A, B, retint[0..n-1]);
cout= retint[n];
tel;

--instancie l'additionneur n bits avec n = 1
function nsub1bit= subnbits<<1>>;

--Multiplexeur 1 bit de contrôle
--renvoit a si uc = true, b sinon
function mux1(a,b,uc :bool) returns(s: bool);
let
s = not uc and a or uc and b;
tel;

function mux14(a,b: bool^4;uc :bool) returns(s: bool^4);
let
s[0..3] = map<<mux1; 4>>(a[0..3],b[0..3],uc^4);
tel;

--Multiplexeur 2 bits de contrôle
-- uc0|uc1|sortie
--  0 | 0 | a 
--  0 | 1 | b
--  1 | 0 | C
--  1 | 1 | d 
function mux2(a,b,c,d,uc0,uc1 :bool) returns(s: bool);
let
s = mux1(mux1(a,b,uc0), mux1(c,d,uc0), uc1);
tel;

function mux24(a,b,c,d :bool^4; uc0, uc1 :bool) returns(s: bool^4);
let
s[0..3] = map<<mux2; 4>>(a[0..3],b[0..3],c[0..3],d[0..3],uc0^4,uc1^4);
tel;

--Effectue une opération or entre chaque bit de T soit renvoit false si au moins un bit vaut true
function nor4bits (T : bool^4) returns (o : bool);
let
o = not(T[0] or T[1] or T[2] or T[3]);
tel;

--Inverse un tableau de booléens
function inverse <<const n:int>>(a : bool^n) returns (ainv : bool^n);
let
	ainv[0..n-1] = map <<not; n>>(a[0..n-1]); -- on inverse chaque bit un à un
tel;

function inv4bits = inverse<<4>>;
function inv1bits = inverse<<1>>;
-------------------------------------------------------------------------------------------------------------------------------------------------------------

--ULM
function ulm(A, B : bool^4; uc0, uc1 :bool) returns (T, X, Y: bool^4;C, C0, C1, C2, N, Z, V : bool);
var Z4, INV4,AOB : bool^4;
let
AOB = mux14(B, A, uc0);
INV4 = inv4bits(AOB);

Z4[0..3] = false^4;

X = mux24(A, INV4, A, Z4, uc0, uc1);
Y = mux24(INV4, Z4, B, B, uc0, uc1);

C0 = (not uc1) or (uc1 and uc0);
(T, C1, C2) = add4(X, Y, C0);

Z = nor4bits(T);
N = T[3] and not uc1;

C = mux1(false, C1, uc1);
V = (C1 xor C2)and not uc1;
tel;

-------------------------------------------------------------------------------------------------------------------------------------------------------------
---Variante
--ULM1bit
function ulm1bit(A, B : bool; uc0, uc1 :bool) returns (T: bool);
var C1, X, Y,AOB : bool;
let
AOB = mux1(B, A, uc0);

X = mux2(A, not A, A, false, uc0, uc1);
Y = mux2(B, false, B, not B, uc0, uc1);

(T, C1) = add1bit(X, Y, false);

tel;



